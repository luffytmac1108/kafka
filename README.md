# 为什么要做这个关于kafka的小demo？
主要是想要测试kafka到底如何实现多实例下topic多分区的顺序消费

# 首先明确一个概念
kafka是允许开发者自定义分区策略的，默认的分区策略是根据key的hash值来进行分区的，但是如果key为null的话，那么就会随机分配一个分区。
当然我们可以自定义分区策略，比如本项目中定义的CustomPartitioner，我们可以根据key进行自定义计算，来确定消息应该分配到哪个分区。

------------------------------------------------------------------------------------------------------------------------

# 带着我的疑问，我们一起探寻一下kafka顺序消费的奥秘
问1：
我们的前提条件是：我的topic有三个分区，我配置的concurrency=3，但是现在我只启动了一个实例，这个肯定可以保证不同分区内的消息是顺序消费的，
如果我现在启动多个实例，是不是多个实例中的多个消费线程会消费同一个分区，那这个时候会不会有这种情况：实例A拿到 “消息1”，实例B拿到 “消息2”，
业务上“消息1”需要比“消息2”先处理，但是实例B先处理了“消息2”。这个时候还是无法保证消息的顺序消费，这个问题kafka是如何来解决的？

答1：
Kafka 保证顺序消费的机制是基于“分区”的：
生产者保证： 具有相同 Kafka Key 的消息会被路由到同一个分区。
消费者组保证： 在一个消费者组内，一个分区在任何时刻都只会被一个消费者实例（确切地说是该实例内的一个消费者线程）消费。
单线程消费保证： 消费者实例内部，一个分区通常由一个线程按顺序地拉取和处理消息。
因此，即使你启动了多个 Spring Boot 实例，只要它们属于同一个消费者组，并且你正确地使用了 Kafka Key 来路由消息到特定分区，那么：
不同 Key 的消息（或落在不同分区的消息） 可以在不同实例/线程上并行消费，提高吞吐量。
相同 Key 的消息（或落在同一个分区的消息） 仍然会由同一个消费者线程顺序消费，保证了它们的处理顺序。

当前配置的 concurrency=3 且 Topic 有 3 个分区
如果你启动多个实例，并且这些实例都属于同一个消费者组，那么分区将会在这些实例之间重新平衡。
例如：

    1 个实例： 实例 A -> P0, P1, P2
    2 个实例： 实例 A -> P0, P1；实例 B -> P2 (分区分配是动态的，取决于协调器)
    3 个实例： 实例 A -> P0；实例 B -> P1；实例 C -> P2

在任何上述情况下，每个分区都只会由一个唯一的消费者实例（及其内部的消费者线程）来消费。
综上，你不需要担心同一个分区内的消息顺序会被打乱。

------------------------------------------------------------------------------------------------------------------------

问2：
测试过程中发现一个问题，现在我的 topic 有3个分区，我的消费线程设置的是concurrency=3，现在我先启动实例A，这个时候会吧 3个分区都给到 实例A，
如果我再启动一个实例B，这个时候不管把哪个分区分配给这个实例B，都会出现一个问题，就是我的topic的同一个分区被分配到了两个不同的实例，
这就会导致顺序性消费被打破， 那么kafka是否会自动判断：当有多个实例启动时，自动重新计算分配分区？

答2：

    a：当只有一个实例（实例A）启动时，如果它配置的消费者线程数（concurrency）大于或等于 Topic 的分区数（3），
    那么实例A会被分配到所有3个分区（P0, P1, P2）。 此时，实例 1 内部的 3 个线程会分别消费这 3 个分区。
    
    b：当你再启动第二个实例（实例B）时，即使实例B也配置了3个消费者线程，但 Kafka 并不会允许出现 “同一个Topic的同一个分区被分配到两个不同的实例” 的情况。

Kafka 的自动分区再平衡 (Rebalance) 机制
是的，Kafka 会自动判断，并且如果有多个实例加入同一个消费者组，它会触发一次 Rebalance（再平衡）操作来重新分配分区。
这是 Kafka 消费者组的关键特性，旨在确保：
同一消费者组内，每个分区在任何给定时间只能被一个消费者实例（确切地说是该实例内的一个消费者线程）消费。分区的分配尽可能均匀，以实现负载均衡。

Rebalance 发生过程：
当你启动第二个实例（实例B）时，会发生以下情况：

    1、实例B加入消费者组： 实例B启动后，会向消费者组协调器（Group Coordinator，通常是 Kafka Broker 中的一个）发送“加入组”的请求。
    
    2、触发 Rebalance： 消费者组协调器检测到组内成员发生变化（有新成员加入），会触发一次 Rebalance。
    
    3、停止消费： 组内的所有活跃消费者（包括实例A 和实例B）都会暂停消费并提交已处理的偏移量。
    
    4、重新分配分区： 协调器根据当前的消费者实例数量和 Topic 的分区数量，重新计算如何将分区分配给每个实例。
    
        在你的例子中，3 个分区 (P0, P1, P2) 和 2 个实例（实例A，实例B）。
        最常见的分区分配策略（例如 RangeAssignor 或 RoundRobinAssignor）会尝试将分区均匀地分配给两个实例。
        例如，实例A 可能会被分配到 P0 和 P1，而实例B 会被分配到 P2。或者实例A -> P0, 实例B -> P1, P2 (具体取决于分配策略和实例 ID)。
    
    5、恢复消费： 分区重新分配完成后，每个实例会收到它现在负责的那些分区的分配信息，然后从这些分区的最后提交的偏移量处继续消费。